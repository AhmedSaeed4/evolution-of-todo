# Kubernetes Manifests Reference

**Feature**: 011-minikube-deployment
**Date**: 2026-01-25
**Purpose**: Document expected Kubernetes resource manifests for reference

## Overview

This document provides example Kubernetes manifests that will be generated by Helm. These are for reference only - actual manifests will be created via `helm create` and customized in values.yaml files.

---

## Secret Manifest

**File**: (Created via kubectl, not Helm)

```bash
kubectl create secret generic phase4-secrets \
  --from-literal=DATABASE_URL='postgresql://neondb_owner:pass@ep-xxx.aws.neon.tech/neondb?sslmode=require' \
  --from-literal=BETTER_AUTH_SECRET='your-secret-key' \
  --from-literal=OPENAI_API_KEY='sk-proj-...' \
  --from-literal=XIAOMI_API_KEY='sk-skpuxlh2zyrktjbl4gb4emirg7vjcbx12beo4zc3j2wib86v'
```

**Generated Manifest** (for reference):
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: phase4-secrets
  namespace: default
type: Opaque
data:
  DATABASE_URL: cG9zdGdyZXNxbDovL25lb25kYl9vd25lcjpwYXNzQGVwLXh4eC5hd3MubmVvbi50ZWNoL25lb25kYj9zc2xtb2RlPXJlcXVpcmU=
  BETTER_AUTH_SECRET: eW91ci1zZWNyZXQta2V5
  OPENAI_API_KEY: c2stcHJvai0uLi4=
  XIAOMI_API_KEY: c2stc2twdXhsaDJ6eXJrdGpibDRnYjRlbWlyZzd2amNiYngxMmJlbzR6YzNqMndpYjg2dg==
```

---

## Backend Deployment Manifest

**Generated by**: `helm install backend ./phase-4/helm-charts/backend`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: default
  labels:
    app.kubernetes.io/name: backend
    app.kubernetes.io/instance: backend
    app.kubernetes.io/version: "v1"
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: backend
      app.kubernetes.io/instance: backend
  template:
    metadata:
      labels:
        app.kubernetes.io/name: backend
        app.kubernetes.io/instance: backend
    spec:
      securityContext: {}
      containers:
        - name: backend
          securityContext: {}
          image: "phase4-backend:v1"
          imagePullPolicy: IfNotPresent
          env:
            - name: CORS_ORIGINS
              value: "http://localhost:3000,http://10.96.0.0:3000"
            - name: API_HOST
              value: "0.0.0.0"
            - name: API_PORT
              value: "8000"
            - name: BETTER_AUTH_URL
              value: "http://frontend:3000"
            - name: DEBUG
              value: "false"
            - name: ENVIRONMENT
              value: "development"
          envFrom:
            - secretRef:
                name: phase4-secrets
          ports:
            - name: http
              containerPort: 8000
              protocol: TCP
          livenessProbe:
            httpGet:
              path: /health
              port: http
            initialDelaySeconds: 10
            periodSeconds: 30
            timeoutSeconds: 3
            successThreshold: 1
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /health
              port: http
            initialDelaySeconds: 5
            periodSeconds: 10
            timeoutSeconds: 3
            successThreshold: 1
            failureThreshold: 3
          resources: {}
```

---

## Backend Service Manifest

**Generated by**: `helm install backend ./phase-4/helm-charts/backend`

```yaml
apiVersion: v1
kind: Service
metadata:
  name: backend
  namespace: default
  labels:
    app.kubernetes.io/name: backend
    app.kubernetes.io/instance: backend
spec:
  type: ClusterIP
  ports:
    - port: 8000
      targetPort: http
      protocol: TCP
      name: http
  selector:
    app.kubernetes.io/name: backend
    app.kubernetes.io/instance: backend
```

---

## Frontend Deployment Manifest

**Generated by**: `helm install frontend ./phase-4/helm-charts/frontend`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: default
  labels:
    app.kubernetes.io/name: frontend
    app.kubernetes.io/instance: frontend
    app.kubernetes.io/version: "v1"
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: frontend
      app.kubernetes.io/instance: frontend
  template:
    metadata:
      labels:
        app.kubernetes.io/name: frontend
        app.kubernetes.io/instance: frontend
    spec:
      securityContext: {}
      containers:
        - name: frontend
          securityContext: {}
          image: "phase4-frontend:v1"
          imagePullPolicy: IfNotPresent
          env:
            - name: NEXT_PUBLIC_BACKEND_URL
              value: "http://backend:8000"
            - name: NEXT_PUBLIC_AUTH_URL
              value: "http://10.96.0.0:3000"  # Replace with actual EXTERNAL-IP
            - name: NEXT_PUBLIC_AUTH_BYPASS
              value: "false"
            - name: NEXT_PUBLIC_CHATKIT_DOMAIN_KEY
              value: "yourdomain.com"
          ports:
            - name: http
              containerPort: 3000
              protocol: TCP
          livenessProbe:
            httpGet:
              path: /api/health
              port: http
            initialDelaySeconds: 5
            periodSeconds: 30
            timeoutSeconds: 3
            successThreshold: 1
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /api/health
              port: http
            initialDelaySeconds: 5
            periodSeconds: 10
            timeoutSeconds: 3
            successThreshold: 1
            failureThreshold: 3
          resources: {}
```

---

## Frontend Service Manifest

**Generated by**: `helm install frontend ./phase-4/helm-charts/frontend`

```yaml
apiVersion: v1
kind: Service
metadata:
  name: frontend
  namespace: default
  labels:
    app.kubernetes.io/name: frontend
    app.kubernetes.io/instance: frontend
spec:
  type: LoadBalancer
  ports:
    - port: 3000
      targetPort: http
      protocol: TCP
      name: http
  selector:
    app.kubernetes.io/name: frontend
    app.kubernetes.io/instance: frontend
```

**Note**: When `minikube tunnel` is running, this service will receive an `EXTERNAL-IP`.

---

## Complete Deployment Sequence

### 1. Pre-deployment

```bash
# Start Minikube
minikube start

# Configure Docker daemon (CRITICAL)
eval $(minikube docker-env)

# Build images
docker build -t phase4-frontend:v1 ./phase-4/frontend
docker build -t phase4-backend:v1 ./phase-4/backend

# Create secret
kubectl create secret generic phase4-secrets \
  --from-literal=DATABASE_URL='...' \
  --from-literal=BETTER_AUTH_SECRET='...' \
  --from-literal=OPENAI_API_KEY='...' \
  --from-literal=XIAOMI_API_KEY='...'
```

### 2. Deploy Backend

```bash
# Install Helm chart
helm install backend ./phase-4/helm-charts/backend

# Verify deployment
kubectl get pods -l app.kubernetes.io/name=backend
kubectl get services backend
```

### 3. Deploy Frontend

```bash
# Install Helm chart
helm install frontend ./phase-4/helm-charts/frontend

# Verify deployment
kubectl get pods -l app.kubernetes.io/name=frontend
kubectl get services frontend
```

### 4. Expose Services

```bash
# Start tunnel (in separate terminal)
minikube tunnel

# Check services for EXTERNAL-IP
kubectl get services
```

**Expected Output**:
```
NAME       TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)
backend    ClusterIP      10.96.100.50    <none>           8000/TCP
frontend   LoadBalancer   10.96.200.100   10.96.200.100    3000:xxxxx/TCP
                                    ^^^^^^^^^^^^^^^^
                                    External IP from tunnel
```

### 5. Access Application

```bash
# Get EXTERNAL-IP
EXTERNAL_IP=$(kubectl get svc frontend -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

# Access frontend
curl http://$EXTERNAL_IP:3000

# Or open in browser
echo "Access at: http://$EXTERNAL_IP:3000"
```

---

## Verification Commands

```bash
# Check all resources
kubectl get all

# Check pod logs
kubectl logs -l app.kubernetes.io/name=backend
kubectl logs -l app.kubernetes.io/name=frontend

# Check pod details
kubectl describe pod <pod-name>

# Check service endpoints
kubectl get endpoints

# Check secret (base64 encoded)
kubectl get secret phase4-secrets -o yaml

# Decode secret value
kubectl get secret phase4-secrets -o jsonpath='{.data.DATABASE_URL}' | base64 -d
```

---

## Cleanup Commands

```bash
# Uninstall Helm releases
helm uninstall frontend
helm uninstall backend

# Delete secret
kubectl delete secret phase4-secrets

# Stop tunnel (press Ctrl+C in tunnel terminal)

# Stop Minikube (optional)
minikube stop

# Delete Minikube cluster (optional)
minikube delete
```

---

## Troubleshooting Manifests

### ImagePullBackOff Error

**Symptom**: Pod status shows `ImagePullBackOff`

**Diagnosis**:
```bash
kubectl describe pod <pod-name>
kubectl get pods -l app.kubernetes.io/name=backend
```

**Cause**: Images not in Minikube's Docker daemon

**Solution**:
```bash
# Re-configure Docker daemon
eval $(minikube docker-env)

# Rebuild images
docker build -t phase4-frontend:v1 ./phase-4/frontend
docker build -t phase4-backend:v1 ./phase-4/backend

# Restart deployment
kubectl rollout restart deployment/backend
kubectl rollout restart deployment/frontend
```

### CrashLoopBackOff Error

**Symptom**: Pod status shows `CrashLoopBackOff`

**Diagnosis**:
```bash
kubectl logs <pod-name>
kubectl describe pod <pod-name>
```

**Common Causes**:
- Missing environment variables (check secrets)
- Database connection failure (check DATABASE_URL)
- Application error (check logs)

### EXTERNAL-IP Shows Pending

**Symptom**: Frontend service EXTERNAL-IP shows `<pending>`

**Diagnosis**:
```bash
# Check if tunnel is running
ps aux | grep "minikube tunnel"
```

**Solution**:
```bash
# Start tunnel in separate terminal
minikube tunnel
```

---

## References

- **Helm Charts**: `phase-4/helm-charts/`
- **Values Files**: `phase-4/helm-charts/*/values.yaml`
- **Templates**: `phase-4/helm-charts/*/templates/`
- **Workflow**: `.claude/skills/minikube-deployment/patterns/WORKFLOW.md`
- **Helm Patterns**: `.claude/skills/minikube-deployment/patterns/HELM_PATTERNS.md`

---

**Manifests Status**: âœ… Complete - Reference manifests documented
